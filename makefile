# This clears all the implicit rules.
.SUFFIXES:

# Utility defines
define compile_obj
$(CXX) -c $< -o $@ $(ALL_CXXFLAGS)
endef

define link_main
$(CXX) -o $@ $^ $(ALL_CXXFLAGS) $(ALL_LDFLAGS)
endef

define generate_dependency
$(CXX) $*.cpp -MM -MP -MF $*.dep.mk -MT '$*.o $*.dep.mk' $(ALL_CXXFLAGS)
endef


# This makefile handles multiple programs in the same directory
# that include several files.
#
# However, some strictness must be followed in the code;
# see "naming_conventions.md" for more information.
CXXFLAGS := -g
ALL_CXXFLAGS := $(CXXFLAGS) -std=c++1y -iquote./ \
	-isystem Catch/single_include $$(pkg-config opencv --cflags) -iquote./
ALL_LDFLAGS += $$(pkg-config opencv --libs) $(LDFLAGS)

# Directories whose makefiles need to be included
INCLUDE := $(wildcard */makefile.mk)

# Subdirecories thad need to be ignored by find.
# For instance, we won't scan directories with their own makefile.
ignore_dirs := $(dir $(INCLUDE))
ignore_dirs := .git Catch $(ignore_dirs:%/=%)
FINDIGNORE := $(patsubst %, -path "./%" -prune -o, $(ignore_dirs))


# Programs generated by this makefile
PROG := $(shell find . $(FINDIGNORE) -name "*.cpp" -exec grep -l "^int main" {} +)
PROG := $(PROG:.cpp=)

# cpp files whose compilation will be managed by this makefile.
SRC := $(shell find . $(FINDIGNORE) -name "*.cpp" -print)

# .dep.mk files that should be automatically generated from .cpp files.
DEP := $(MAIN:.cpp=.dep.mk) $(NOMAIN:.cpp=.dep.mk)

# Object files that contains definitions needed by other programs
OBJ := $(shell find . $(FINDIGNORE) -name "*.cpp" -exec grep -L "^int main" {} +)
OBJ := $(OBJ:.cpp=.o)

# The makefile will generate rules for treating the files in
# PROG, SRC and DEP automatically.
# So, submakefiles may append files to these variables
# to request the specified service.
include $(INCLUDE)


-include $(DEP)


.DEFAULT_GOAL := all

.PHONY: all
all: $(PROG)

# Suboptimal dependency management.
# I have made every program depend on every non-main object file;
# this way I can guarantee that the object file will be remade
# whenever any module used by an artifficial inteligence is updated.
#
# Resolving this without such intrusion would need to somehow
# inspect the object files and tell make which symbols are defined
# in each object. This inspection could be done by using by somehow parsing
# 'nm -u' (to get the dependecies) and 'nm | grep " *[TtRr]"' (to get the
# provided symbols), but I have no idea of how to dynamically update
# the make's DAG without invoking make repeatedly
# --- which should be make's work.
$(PROG): %: %.o $(OBJ)
	$(link_main)

$(SRC:.cpp=.o): %.o : %.cpp
	$(compile_obj)

$(DEP): %.dep.mk: %.cpp
	$(generate_dependency)

.PHONY: mostlyclean clean
mostlyclean:
	-find $(FINDIGNORE) -name "*.o" -exec rm '{}' \;
	-find -name "*.dep.mk" -exec rm '{}' \;

clean: mostlyclean
	-rm -f $(PROG)
