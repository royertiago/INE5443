namespace command_line {
    const char help_message[] =
"$0 [options]\n"
"Generate a list of entry points that can be used to visuzlize\n"
"the influence areas of each entry.\n"
"The generated points are organized in a grid.\n"
"The dataset on which we will be based to make such observations\n"
"is read in stdin.\n"
"Output is printed on stdout.\n"
"\n"
"Only the attributes are generated by this program, not the categories.\n"
"\n"
"Options:\n"
"\n"
"--dimensions <comma-separated list>\n"
"    Defines how much points should be generated\n"
"    for each of the dimensions of the dataset.\n"
"    By default, we generate 100 for each attribute.\n"
"    (Note that, for an (e. g.) bidimensional dataset,\n"
"    this will casue 100*100 = 10 000 points to be generated.)\n"
"\n"
"--expand <F>\n"
"    How much we should expand the grid, related to\n"
"    the extremum points of the datsaet.\n"
"    Default: 0.1. (= 10%)\n"
"\n"
"--help\n"
"    Display this help and exit.\n"
;
} // namespace command_line

#include <getopt.h>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cfloat>
#include <map>
#include <vector>
#include "pr/data_entry.h"
#include "pr/data_set.h"

namespace command_line {
    std::vector<unsigned> dimensions;
    double expand = 0.1;

    void parse( int argc, char ** argv ) {
        static option options[] = {
            {"dimensions", required_argument, 0, 'd'},
            {"expand", required_argument, 0, 'e'},
            {"help", no_argument, 0, 'h'},
            {0, 0, 0, 0},
        };
        int opt;
        int dummy_option_index;
        char * tok;
        int dimension;
        while( (opt = getopt_long( argc, argv, "d:e:h",
                    options, &dummy_option_index
                )) != -1 ) {
            switch( opt ) {
                case 'd':
                    tok = std::strtok(optarg, ",");
                    while( tok != nullptr ) {
                        if( std::sscanf(tok, "%d", &dimension) != 1 ) {
                            std::fprintf( stderr, "Not a valid number: %s\n", tok );
                            std::exit(1);
                        }
                        if( dimension <= 0 ) {
                            std::fprintf( stderr,
                                "Dimension numbers must be positive.\n" );
                            std::exit(1);
                        }
                        dimensions.push_back(dimension);
                        tok = std::strtok(nullptr, ",");
                    }
                    break;
                case 'e':
                    if( std::sscanf( optarg, "%lf", &expand ) != 1 ) {
                        std::fprintf( stderr, "Not a valid number: %s\n", optarg );
                        std::exit(1);
                    }
                    if( expand < 0 ) {
                        std::fprintf( stderr, "Expansion must be non-negative.\n" );
                        std::exit(1);
                    }
                    break;
                case 'h':
                    std::printf( help_message, argv[0] );
                    std::exit(0);
                    break;
                default:
                    std::fprintf( stderr, "Unknown parameter %c\n", optopt );
                    std::exit(1);
            }
        }
    } // void parse(int, char**)
} // namespace command_line

int main( int argc, char ** argv ) {
    using command_line::dimensions;

    command_line::parse( argc, argv );
    DataSet dataset = DataSet::parse( stdin );
    if( dimensions.size() == 0 )
        dimensions = std::vector<unsigned>(
            dataset.attribute_count(),
            100
        );
    if( dimensions.size() != dataset.attribute_count() ) {
        std::fprintf( stderr, "Size of dimension vector"
                " do not match attribute count in dataset.\n" );
        std::exit(2);
    }

    std::vector<double> min( dimensions.size(), DBL_MAX );
    std::vector<double> max( dimensions.size(), -DBL_MAX );
    for( const DataEntry & entry : dataset ) {
        for( unsigned i = 0; i < entry.attribute_count(); i++ ) {
            min[i] = std::min(min[i], entry.attribute(i));
            max[i] = std::max(max[i], entry.attribute(i));
        }
    }

    std::vector<double> step( dimensions.size() );
    for( unsigned i = 0; i < dataset.attribute_count(); i++ )
        step[i] = (max[i] - min[i]) * (1+2*command_line::expand) /
            dimensions[i];

    std::vector<double> shift( dimensions.size() );
    for( unsigned i = 0; i < dataset.attribute_count(); i++ )
        shift[i] = (max[i] - min[i]) * command_line::expand;

    std::vector<unsigned> i( dimensions.size() );
    while( true ) {
        const char * separator = "";
        for( int j = 0; j < i.size(); j++ ) {
            std::printf( "%s%lf", separator, i[j] * step[j] + min[j] - shift[j] );
            separator = ",";
        }
        std::printf( "\n" );
        for( int j = i.size() - 1; ; j-- ) {
            if( j < 0 ) goto exit_loop;
            i[j]++;
            if( i[j] > dimensions[j] )
                i[j] = 0;
            else
                break;
        }
    }
exit_loop:
    return 0;
}
